"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var escapeRegexString = require("escape-string-regexp");
exports.escapeRegexString = escapeRegexString;
function sanitizeParameter(param, spaceAllowed) {
    if (spaceAllowed === void 0) { spaceAllowed = false; }
    if (spaceAllowed) {
        return param.replace(/[\0\r\n]/g, '');
    }
    else {
        return param.replace(/[\0\r\n ]/g, '');
    }
}
exports.sanitizeParameter = sanitizeParameter;
function padLeft(str, length, padding) {
    if (typeof str === 'number') {
        str = str.toString();
    }
    length = length - str.length;
    if (length <= 0) {
        return str;
    }
    if (padding === undefined) {
        padding = ' ';
    }
    var paddingStr = '';
    do {
        // tslint:disable:no-bitwise
        if ((length & 1) === 1) {
            paddingStr += padding;
        }
        length >>= 1;
        if (length) {
            padding += padding;
        }
        // tslint:enable:no-bitwise
    } while (length);
    return paddingStr + str;
}
exports.padLeft = padLeft;
function isChannel(str, validTypes) {
    if (validTypes === void 0) { validTypes = '#&'; }
    var re = new RegExp("^[" + escapeRegexString(validTypes) + "][^ \b\0\n\r,]+$");
    return re.test(str);
}
exports.isChannel = isChannel;
var ctcpEscapeMap = {
    0: '\0',
    n: '\n',
    r: '\r',
    '\x10': '\x10'
};
function decodeCtcp(message) {
    if (message[0] !== '\x01') {
        // this is not a CTCP message
        return false;
    }
    message = message.substring(1);
    // remove trailing \x01 if present
    if (message.slice(-1) === '\x01') {
        message = message.slice(0, -1);
    }
    if (!message) {
        // completely empty CTCPs don't exist either, I think
        return false;
    }
    // unescape weirdly escaped stuff
    message = message.replace(/\x10(.)/, function (_, escapedChar) {
        return (escapedChar in ctcpEscapeMap) ? ctcpEscapeMap[escapedChar] : '';
    });
    var _a = __read(message.split(' ', 2), 2), command = _a[0], _b = _a[1], params = _b === void 0 ? '' : _b;
    command = command ? command.toUpperCase() : '';
    return { command: command, params: params };
}
exports.decodeCtcp = decodeCtcp;
//# sourceMappingURL=StringTools.js.map