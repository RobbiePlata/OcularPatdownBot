/// <reference types="node" />
import Connection, { ConnectionInfo } from './Connection/Connection';
import Message, { MessageConstructor } from './Message/Message';
import MessageCollector from './Message/MessageCollector';
import Capability, { ServerCapability } from './Capability/Capability';
import { EventEmitter, Listener } from './TypedEventEmitter';
import { PrivateMessage, Notice } from './Message/MessageTypes/Commands';
import { ConstructedType, MessageParams } from './Toolkit/TypeTools';
export declare type EventHandler<T extends Message = Message> = (message: T) => void;
export declare type EventHandlerList<T extends Message = Message> = Map<string, EventHandler<T>>;
export interface SupportedChannelModes {
    list: string;
    alwaysWithParam: string;
    paramWhenSet: string;
    noParam: string;
}
interface ClientOptions {
    connection: ConnectionInfo;
    webSocket?: boolean;
    channelTypes?: string;
    logLevel?: number;
}
export default class Client extends EventEmitter {
    protected _connection: Connection;
    protected _nick: string;
    protected _userName: string;
    protected _realName: string;
    protected _registered: boolean;
    protected _supportsCapabilities: boolean;
    protected _events: Map<string, EventHandlerList>;
    protected _registeredMessageTypes: Map<string, MessageConstructor>;
    onConnect: (handler: () => void) => Listener;
    onRegister: (handler: () => void) => Listener;
    onDisconnect: (handler: (reason?: Error) => void) => Listener;
    onPrivmsg: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onAction: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onNotice: (handler: (target: string, user: string, message: string, msg: Notice) => void) => Listener;
    onCtcp: (handler: (target: string, user: string, command: string, params: string, msg: PrivateMessage) => void) => Listener;
    onCtcpReply: (handler: (target: string, user: string, command: string, params: string, msg: Notice) => void) => Listener;
    protected _channelTypes: string;
    protected _supportedUserModes: string;
    protected _supportedChannelModes: SupportedChannelModes;
    protected _supportedFeatures: {
        [feature: string]: true | string;
    };
    protected _collectors: MessageCollector[];
    protected _clientCapabilities: Map<string, Capability>;
    protected _serverCapabilities: Map<string, ServerCapability>;
    protected _negotiatedCapabilities: Map<string, ServerCapability>;
    protected _pingOnInactivity: number;
    protected _pingTimeout: number;
    protected _pingCheckTimer?: NodeJS.Timer;
    protected _pingTimeoutTimer?: NodeJS.Timer;
    private readonly _logger;
    constructor({ connection, webSocket, channelTypes, logLevel }: ClientOptions);
    pingCheck(): void;
    reconnect(message?: string): Promise<void>;
    registerMessageType(cls: MessageConstructor): void;
    knowsCommand(command: string): boolean;
    getCommandClass(command: string): MessageConstructor | undefined;
    protected registerCoreMessageTypes(): void;
    connect(): Promise<void>;
    waitForRegistration(): Promise<void>;
    protected _negotiateCapabilityBatch(capabilities: ServerCapability[][]): Promise<Array<ServerCapability[] | Error>>;
    protected _negotiateCapabilities(capList: ServerCapability[]): Promise<ServerCapability[] | Error>;
    registerCapability(cap: Capability): Promise<Error | ServerCapability[]>;
    send(message: Message): void;
    onMessage<C extends MessageConstructor>(type: C, handler: EventHandler<ConstructedType<C>>, handlerName?: string): string;
    onMessage<T extends Message>(type: string, handler: EventHandler, handlerName?: string): string;
    removeMessageListener(handlerName: string): void;
    createMessage<T extends MessageConstructor>(type: T, params: MessageParams<ConstructedType<T>>): ConstructedType<T>;
    sendMessage<T extends MessageConstructor>(type: T, params: MessageParams<ConstructedType<T>>): void;
    sendMessageAndCaptureReply<T extends Message>(type: MessageConstructor<T>, params: MessageParams<T>): Promise<Message[]>;
    readonly channelTypes: string;
    readonly supportedChannelModes: SupportedChannelModes;
    readonly isConnected: boolean;
    readonly isConnecting: boolean;
    readonly isRegistered: boolean;
    /** @private */
    collect(originalMessage: Message, ...types: MessageConstructor[]): MessageCollector;
    /** @private */
    stopCollect(collector: MessageCollector): void;
    join(channel: string, key?: string): void;
    part(channel: string): void;
    quit(message?: string): Promise<void>;
    say(target: string, message: string): void;
    private handleEvents;
    private _startPingCheckTimer;
}
export {};
