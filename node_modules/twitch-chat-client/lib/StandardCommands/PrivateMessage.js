"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Commands_1 = require("ircv3/lib/Message/MessageTypes/Commands/");
var ChatUser_1 = require("../ChatUser");
var ChatTools_1 = require("../Toolkit/ChatTools");
var TwitchPrivateMessage = /** @class */ (function (_super) {
    tslib_1.__extends(TwitchPrivateMessage, _super);
    function TwitchPrivateMessage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TwitchPrivateMessage.prototype, "userInfo", {
        get: function () {
            return new ChatUser_1.default(this._prefix.nick, this._tags, this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchPrivateMessage.prototype, "channelId", {
        get: function () {
            if (!this._tags) {
                return null;
            }
            return this._tags.get('room-id') || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchPrivateMessage.prototype, "isCheer", {
        get: function () {
            if (!this._tags) {
                return false;
            }
            return this._tags.has('bits');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchPrivateMessage.prototype, "totalBits", {
        get: function () {
            if (!this._tags) {
                return 0;
            }
            return Number(this._tags.get('bits'));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @deprecated alternative coming soon
     */
    TwitchPrivateMessage.prototype.getSeparateBits = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, cheermotes, names, re, match, totalAmount, name_1, amount;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = [];
                        if (!(this.isCheer && this.channelId)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._client._twitchClient.bits.getCheermotes(this.channelId)];
                    case 1:
                        cheermotes = _a.sent();
                        names = cheermotes.getPossibleNames();
                        re = new RegExp('(?<=^|\s)([a-z]+)(\d+)(?=\s|$)', 'gi');
                        match = void 0;
                        totalAmount = 0;
                        // tslint:disable-next-line:no-conditional-assignment
                        while (match = re.exec(this.params.message)) {
                            name_1 = match[1].toLowerCase();
                            amount = Number(match[2]);
                            if (names.includes(name_1)) {
                                result.push({
                                    name: name_1,
                                    amount: amount,
                                    position: match.index
                                });
                                totalAmount += amount;
                            }
                        }
                        if (totalAmount !== this.totalBits) {
                            console.warn("Incorrect amount of total bits: expected " + this.totalBits + ", got " + totalAmount);
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/, result];
                }
            });
        });
    };
    Object.defineProperty(TwitchPrivateMessage.prototype, "emoteOffsets", {
        get: function () {
            if (!this._tags) {
                return new Map;
            }
            return ChatTools_1.default.parseEmotes(this._tags.get('emotes'));
        },
        enumerable: true,
        configurable: true
    });
    return TwitchPrivateMessage;
}(Commands_1.PrivateMessage));
exports.default = TwitchPrivateMessage;
//# sourceMappingURL=PrivateMessage.js.map